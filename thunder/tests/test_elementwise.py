from torch.testing import assert_close

import thunder
import thunder.core.lang as tlang

from .framework import executors, ops, run_snippet
from .opinfos import elementwise_binary_ops, elementwise_unary_ops

from torch.testing import assert_close, make_tensor
import thunder.langs.torch as ttorch

# Tests for elementwise binary operators


# Snippets run a single test using a single sample
# TODO: should snippets be able to access the original opinfo? -- No?
def snippet_torch_consistency(op, torch_op, sample):
    thunder_result = op(*sample.args, **sample.kwargs)
    torch_result = torch_op(*sample.args, **sample.kwargs)

    assert_close(thunder_result, torch_result, equal_nan=True)


# TODO: consider structuring tests like this to be autogenerated
#   using a snippet and an "extractor" that constructs the args and kwargs for the snippet
@ops(
    elementwise_unary_ops + elementwise_binary_ops,
)
def test_core_vs_torch_consistency(op, device, dtype, executor):
    for sample in op.sample_inputs(device, dtype):
        result = run_snippet(
            snippet_torch_consistency,
            op,
            device,
            dtype,
            executor.make_callable(op.op),
            op.torch_reference,
            sample,
        )
        if result is not None:
            return result


# TODO: test that the operator variant works properly
# TODO: add error inputs tests (like test_elementwise_binary_prim_shape_mismatch and test_elementwise_binary_prim_dtype_mismatch)
# TODO: generate the following tests using opinfos (more number sample inputs needed)


@executors(dtypes=(thunder.float32,))
def test_abs_integer(executor, device, dtype):
    def foo(a, b):
        a_abs = tlang.abs(a)
        return tlang.add(a_abs, b)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = -3
    b = make_tensor((1, 8), device=device, dtype=tdtype)

    thunder_result = traced_foo(a, b)
    torch_result = 3 + b
    assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_abs_float(executor, device, dtype):
    def foo(a, b):
        a_abs = tlang.abs(a)
        return tlang.add(a_abs, b)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = -2.7
    b = make_tensor((1, 8), device=device, dtype=tdtype)

    thunder_result = traced_foo(a, b)
    torch_result = abs(a) + b
    assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_core_tensor_methods(executor, device, dtype):
    def foo(a, b, c, d):
        return a + b - c + (d - a)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = torch.testing.make_tensor((4, 4), device=device, dtype=tdtype)
    b = torch.testing.make_tensor((2, 1, 4), device=device, dtype=tdtype)
    c = torch.testing.make_tensor((4, 1), device=device, dtype=tdtype)
    d = torch.testing.make_tensor((1, 1, 4), device=device, dtype=tdtype)

    thunder_result = traced_foo(a, b, c, d)
    torch_result = a + b - c + (d - a)
    assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_add_integer_constant(executor, device, dtype):
    def foo(a, b):
        c = tlang.add(a, 2)
        return tlang.add(c, b)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = torch.testing.make_tensor((2, 1), device=device, dtype=tdtype)
    b = torch.testing.make_tensor((1, 2), device=device, dtype=tdtype)

    thunder_result = traced_foo(a, b)
    torch_result = (a + 2) + b

    torch.testing.assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_add_integer_input(executor, device, dtype):
    def foo(a, b):
        return tlang.add(a, b)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = make_tensor((2, 1), device=device, dtype=tdtype)

    thunder_result = traced_foo(a, 3)
    torch_result = a + 3

    assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_add_integer_inputs(executor, device, dtype):
    def foo(a, b, c):
        d = tlang.add(a, b)
        return tlang.add(c, d)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = make_tensor((3, 2), device=device, dtype=tdtype)

    thunder_result = traced_foo(3, 4, a)
    torch_result = 3 + 4 + a
    assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_add_integer_constants(executor, device, dtype):
    def foo(a):
        b = tlang.add(2, 3)
        return tlang.add(a, b)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = make_tensor((2, 4), device=device, dtype=tdtype)

    thunder_result = traced_foo(a)
    torch_result = 5 + a
    assert_close(thunder_result, torch_result)


@executors(dtypes=(thunder.float32,))
def test_add_floats(executor, device, dtype):
    def foo(a, b):
        c = tlang.add(2.0, a)
        return tlang.add(b, c)

    traced_foo = thunder.make_traced(foo, executor=executor)

    tdtype = ttorch.torch_dtype(dtype)
    a = make_tensor((2, 4), device=device, dtype=tdtype)

    thunder_result = traced_foo(0.7, a)
    torch_result = 2.0 + 0.7 + a
    assert_close(thunder_result, torch_result)
