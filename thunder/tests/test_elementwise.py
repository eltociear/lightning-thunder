from itertools import product
import os
import pytest

import thunder
import thunder.core.lang as tlang
import thunder.core.utils as utils

import thunder.langs.torch as ttorch

from .opinfos import elementwise_unary_ops, elementwise_binary_ops
from .framework import ops, run_snippet

from torch.testing import assert_close

# TODO: sample across executor_types and devices
from thunder.tests import executor_type, supported_device_types


# Tests for elementwise binary operators

# Snippets run a single test using a single sample
# TODO: should snippets be able to access the original opinfo? -- No
def snippet_torch_consistency(op, torch_op, sample):
    traced_op = thunder.make_traced(op, executor=executor_type)
    thunder_result = traced_op(*sample.args, **sample.kwargs)

    torch_result = torch_op(*sample.args, **sample.kwargs)

    assert_close(thunder_result, torch_result)


# TODO: consider structuring tests like this to be autogenerated
#   using a snippet and an "extractor" that constructs the args and kwargs for the snippet
@ops(
    elementwise_unary_ops + elementwise_binary_ops,
    supported_device_types=supported_device_types,
)
def test_core_vs_torch_consistency(op, device, dtype):
    for sample in op.sample_inputs(device, dtype):
        result = run_snippet(
            snippet_torch_consistency,
            op,
            device,
            dtype,
            op.op,
            op.torch_reference,
            sample,
        )
        if result is not None:
            return result


# TODO: test that the operator variant works properly
